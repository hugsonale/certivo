<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Certivo Prime Flow - Liveness & Dashboard</title>
<style>
    body {
        font-family: Arial, sans-serif;
        background: #0f172a;
        color: #e5e7eb;
        text-align: center;
        padding: 20px;
    }
    video {
        width: 320px;
        border-radius: 12px;
        margin-top: 10px;
    }
    button {
        margin-top: 15px;
        padding: 10px 20px;
        border-radius: 8px;
        border: none;
        cursor: pointer;
        font-weight: bold;
    }
    #status {
        margin-top: 15px;
        font-weight: bold;
        min-height: 50px;
    }
    #dashboardContainer {
        width: 500px;
        margin: 20px auto;
    }
    canvas#overlay {
        position: absolute;
        top: 0;
        left: 0;
        pointer-events: none;
    }
</style>
</head>
<body>

<h1>Certivo Prime Verification - Liveness</h1>

<div style="position: relative; display: inline-block;">
    <video id="video" autoplay muted></video>
    <canvas id="overlay"></canvas>
</div>

<br>
<button id="startBtn">Start Verification</button>
<p id="status">Idle</p>

<div id="dashboardContainer">
    <canvas id="dashboardChart"></canvas>
</div>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.21.0"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/facemesh"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<script>
/* ------------------------
   GLOBAL STATE
------------------------ */
let video = document.getElementById("video");
let overlay = document.getElementById("overlay");
let overlayCtx = overlay.getContext("2d");
let statusEl = document.getElementById("status");
let startBtn = document.getElementById("startBtn");

let faceModel;
let mediaRecorder;
let recordedChunks = [];
let faceCheckInterval;

let canRecord = false;
let verificationCompleted = false;

let challenges = [];
let challengeIndex = 0;
let currentChallenge = null;

/* ------------------------
   METRICS
------------------------ */
let challengeShownAt = null;
let faceMovementTotal = 0;
let faceFrames = 0;
let lastFaceBox = null;
let blinkCount = 0;
let lastEAR = null;

let sessionMetrics = {
    reactionTimes: [],
    faceStabilityScores: [],
    blinkCounts: []
};

/* ------------------------
   DASHBOARD
------------------------ */
let dashboardChart;
let challengeLabels = [];
let reactionData = [];
let stabilityData = [];
let blinkData = [];

function initDashboard(){
    const ctx = document.getElementById('dashboardChart').getContext('2d');
    dashboardChart = new Chart(ctx,{
        type:'line',
        data:{
            labels:challengeLabels,
            datasets:[
                {label:'Reaction Time (ms)', data:reactionData, borderColor:'#f87171', tension:0.3},
                {label:'Face Stability', data:stabilityData, borderColor:'#22c55e', tension:0.3},
                {label:'Blink Count', data:blinkData, borderColor:'#60a5fa', tension:0.3}
            ]
        },
        options:{responsive:true, scales:{y:{beginAtZero:true}}}
    });
}

/* ------------------------
   CAMERA
------------------------ */
async function initCamera() {
    const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
    video.srcObject = stream;
    video.addEventListener('loadeddata', ()=>{
        overlay.width = video.videoWidth;
        overlay.height = video.videoHeight;
    });
}

/* ------------------------
   EAR
------------------------ */
function computeEAR(landmarks) {
    const leftEye = landmarks.slice(33,42);
    const rightEye = landmarks.slice(133,142);
    function ear(eye){
        const A = Math.hypot(eye[1][0]-eye[5][0], eye[1][1]-eye[5][1]);
        const B = Math.hypot(eye[2][0]-eye[4][0], eye[2][1]-eye[4][1]);
        const C = Math.hypot(eye[0][0]-eye[3][0], eye[0][1]-eye[3][1]);
        return (A+B)/(2*C);
    }
    return (ear(leftEye)+ear(rightEye))/2;
}

/* ------------------------
   FACE CHECK
------------------------ */
async function startFaceCheck() {
    faceCheckInterval = setInterval(async () => {
        if (verificationCompleted) return;

        const predictions = await faceModel.estimateFaces(video);
        overlayCtx.clearRect(0,0,overlay.width,overlay.height);

        if(predictions.length!==1){
            canRecord=false;
            statusEl.innerText="âš ï¸ Ensure one face is visible";
            return;
        }

        canRecord=true;
        const face=predictions[0];
        const [x1,y1]=face.topLeft;
        const [x2,y2]=face.bottomRight;

        overlayCtx.strokeStyle="lime";
        overlayCtx.lineWidth=2;
        overlayCtx.strokeRect(x1,y1,x2-x1,y2-y1);

        if(lastFaceBox){
            faceMovementTotal+=Math.abs(x1-lastFaceBox[0])+Math.abs(y1-lastFaceBox[1]);
            faceFrames++;
        }
        lastFaceBox=[x1,y1];

        const ear=computeEAR(face.scaledMesh);
        if(lastEAR && lastEAR>0.25 && ear<0.20) blinkCount++;
        lastEAR=ear;

        statusEl.innerText=`âœ… Face OK | Blinks: ${blinkCount}`;
    },200);
}

/* ------------------------
   LOAD CHALLENGES
------------------------ */
async function loadChallenges(){
    const res = await fetch("http://127.0.0.1:8000/v1/challenge");
    if(!res.ok){
        statusEl.innerText="âŒ Failed to load challenges";
        return;
    }

    const data = await res.json();
    if(!data.challenges || !data.challenges.length){
        statusEl.innerText="âŒ No challenges received";
        return;
    }

    challenges = data.challenges;
    challengeIndex = 0;
    loadNextChallenge();
}

function loadNextChallenge(){
    if(challengeIndex >= challenges.length){
        statusEl.innerText="ðŸŽ‰ Session Complete";
        clearInterval(faceCheckInterval);
        return;
    }

    currentChallenge = challenges[challengeIndex++];

    // reset metrics
    faceMovementTotal = 0;
    faceFrames = 0;
    blinkCount = 0;
    lastFaceBox = null;
    lastEAR = null;

    challengeShownAt = Date.now();
    statusEl.innerText = "ðŸ§  Challenge: " + currentChallenge.instruction;

    waitForFaceThenRecord();
}

/* ------------------------
   RECORD
------------------------ */
function startRecording(){
    recordedChunks=[];
    mediaRecorder=new MediaRecorder(video.srcObject);
    sessionMetrics.reactionTimes.push(Date.now()-challengeShownAt);

    mediaRecorder.ondataavailable=e=>recordedChunks.push(e.data);
    mediaRecorder.onstop=submitRecording;
    mediaRecorder.start();

    setTimeout(()=>mediaRecorder.stop(),3000);
}

/* ------------------------
   SUBMIT
------------------------ */
async function submitRecording(){
    verificationCompleted=true;

    const faceStability = faceFrames?Math.round(faceMovementTotal/faceFrames):0;

    const blob=new Blob(recordedChunks,{type:"video/webm"});
    const formData=new FormData();
    formData.append("video",blob);
    formData.append("challenge_id",currentChallenge.challenge_id);
    formData.append("device_id","web");

    const res = await fetch("http://127.0.0.1:8000/v1/verify",{method:"POST",body:formData});
    const result = await res.json();

    statusEl.innerHTML = result.verified ? "âœ… VERIFIED" : "âŒ FAILED";

    challengeLabels.push(`Ch ${challengeIndex}`);
    reactionData.push(sessionMetrics.reactionTimes.at(-1));
    stabilityData.push(faceStability);
    blinkData.push(blinkCount);
    dashboardChart.update();

    verificationCompleted=false;
    setTimeout(loadNextChallenge,2000);
}

/* ------------------------
   FLOW
------------------------ */
function waitForFaceThenRecord(){
    const i=setInterval(()=>{
        if(canRecord){
            clearInterval(i);
            startRecording();
        }
    },300);
}

/* ------------------------
   INIT
------------------------ */
startBtn.onclick=async()=>{
    startBtn.disabled=true;
    await initCamera();
    faceModel=await facemesh.load();
    initDashboard();
    await loadChallenges();
    startFaceCheck();
};
</script>
</body>
</html>
